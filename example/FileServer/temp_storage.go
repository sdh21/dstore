package FileServer

import (
	cryptoRand "crypto/rand"
	"crypto/sha512"
	"encoding/base64"
	"github.com/gorilla/securecookie"
	"github.com/sdh21/dstore/cert"
	"github.com/sdh21/dstore/kvstore"
	"math/rand"
	"strconv"
	"sync"
	"sync/atomic"
	"time"
)

// TemporaryStorage is shared among different services
// in this example project. It includes in-memory
// session data, an ID generator, and
// a shared db access layer.

type TemporaryStorage struct {
	// serverId must be unique, used for clientId for db
	// and reject tokens generated by other servers.
	serverId int64

	myHttpAddr string

	mu            sync.RWMutex
	sessionTokens map[string]*SessionData
	// wraps a kvdb client
	db *kvstore.DBAccessLayer

	uniqueTokenId int64

	// when we are started, part of the unique id
	// to avoid id collision if the service is restarted
	startTimestamp time.Time

	// temporary solution;
	// might be replaced later
	secureCookie *securecookie.SecureCookie
}

func NewTemporaryStorage(serverId int64, dbServers []string, dbTLSConfig *cert.MutualTLSConfig, httpAddr string) *TemporaryStorage {
	ts := &TemporaryStorage{
		serverId:      serverId,
		myHttpAddr:    httpAddr,
		sessionTokens: map[string]*SessionData{},
		// we simply use the FileServer server id for the db client id
		db:             kvstore.NewDBAccessLayer(16, dbServers, serverId, dbTLSConfig),
		uniqueTokenId:  0,
		startTimestamp: time.Now(),
		secureCookie:   nil,
	}

	var hashKey = securecookie.GenerateRandomKey(64)
	var blockKey = securecookie.GenerateRandomKey(32)
	ts.secureCookie = securecookie.New(hashKey, blockKey)
	return ts
}

type SessionData struct {
	lock      sync.RWMutex
	csrfToken string
	userId    string
	userToken string
	// service custom data
	c map[string]string
}

func NewSessionData() *SessionData {
	return &SessionData{
		c: map[string]string{},
	}
}

func (ts *TemporaryStorage) generateRandomUniqueToken(tag string) string {
	buf := make([]byte, 256)
	_, err := cryptoRand.Read(buf)
	if err != nil {
		rand.Read(buf)
	}
	buf = append(buf, tag...)
	sha := sha512.Sum512(buf)
	digest := sha[:]
	uniquePart := atomic.AddInt64(&ts.uniqueTokenId, 1)<<10 | ts.serverId
	digest = append(digest, ([]byte)(strconv.FormatInt(uniquePart, 16))...)
	digest = append(digest, ([]byte)("-")...)
	timestampPart := ts.startTimestamp.Unix()
	digest = append(digest, ([]byte)(strconv.FormatInt(timestampPart, 16))...)
	token := base64.StdEncoding.EncodeToString(digest)
	return token
}

func (ts *TemporaryStorage) getSessionFromToken(sessionToken string) (*SessionData, bool) {
	ts.mu.RLock()
	defer ts.mu.RUnlock()

	data, found := ts.sessionTokens[sessionToken]
	return data, found
}

// retrieveSession is similar to getSessionFromToken, but it assumes the session exists.
func (ts *TemporaryStorage) retrieveSession(sessionToken string) *SessionData {
	ts.mu.Lock()
	defer ts.mu.Unlock()
	return ts.sessionTokens[sessionToken]
}

func (ts *TemporaryStorage) getSessionFromCookie(cookie string) (*SessionData, bool) {
	token, found := ts.parseCookieValue(cookie)
	if !found {
		return nil, false
	}
	return ts.getSessionFromToken(token)
}

func (ts *TemporaryStorage) parseCookieValue(cookie string) (string, bool) {
	value := make(map[string]string)
	err := ts.secureCookie.Decode("token", cookie, &value)
	if err != nil {
		return "", false
	}
	token, found := value["value"]
	if !found {
		return "", false
	}
	forwarderId, found := value["forwarderId"]
	if !found {
		return "", false
	}
	if forwarderId != strconv.FormatInt(ts.serverId, 10) {
		return "", false
	}
	timestamp, found := value["timestamp"]
	if !found {
		return "", false
	}
	createTime, err := strconv.ParseInt(timestamp, 10, 64)
	if err != nil {
		return "", false
	}
	if time.Since(time.Unix(createTime, 0)) > 12*time.Hour {
		return "", false
	}
	return token, true
}

func (ts *TemporaryStorage) issueCookieValue(tag string) (string, string, error) {
	value := map[string]string{}
	value["value"] = ts.generateRandomUniqueToken(tag)
	value["forwarderId"] = strconv.FormatInt(ts.serverId, 10)
	value["timestamp"] = strconv.FormatInt(time.Now().Unix(), 10)
	encoded, err := ts.secureCookie.Encode("token", value)
	if err != nil {
		return "", "", err
	}
	return value["value"], encoded, nil
}

func (ts *TemporaryStorage) createSession(sessionToken string) {
	ts.mu.Lock()
	defer ts.mu.Unlock()
	ts.sessionTokens[sessionToken] = NewSessionData()
}
